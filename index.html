<html>
<head>
    <title>WebGl Waves</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.11.2/lodash.js" type="text/javascript"></script>
    <script type="text/javascript" src="dat.gui.min.js"></script>
    <script src="driver.js" type="text/javascript"></script>
    <style>
        * {
            margin:0;
            padding:0;
        }
        canvas {
            width:100%;
            height:100%;
        }
        .stats table * {
            color: cornflowerblue;
            font-family: Sans-Serif;
        }
    </style>
    <script id="shader-vs" type="x-shader/x-vertex">
precision mediump float;
attribute vec2 vertPosition;
void main() {
  gl_Position = vec4(vertPosition, 0.0, 1.0);
}
    </script>
    <script id="shader-fs" type="x-shader/x-fragment">
#extension GL_OES_standard_derivatives : enable

#ifdef GL_ES
precision mediump float;
#endif

uniform int waveType;
uniform float time;
uniform int mode;
uniform vec2 resolution;
const int wavesLength = ${wavesLength};
uniform vec4 waves[wavesLength]; // [x,y,time,hue]

const float PI = 3.1415926535897932384626433832795;
const float PI2 = 2.0 * PI;

/** cycle smoothly from 0 to 1 and back over the specified period in seconds */
float timeCycle(float offset, float period) {
    float smooth = .5 * (1.0 + sin((time + offset) * PI2/period));
    return smooth;
}

/** convert hsv to rgb. from: http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl */
vec3 hsv2rgb(vec3 c) {
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

/** color via sin wave tamped by decaying exponential */
vec3 decayingSine(vec4 wave,vec2 pos) {
    vec2 fromCenter = abs(wave.xy - pos / resolution.yy);
    float distance = length(fromCenter);
    float hue = wave.w;
    float startTime = wave.z;

    float decayRate = -4.0;
    float scale = .5;
    float offset = 1.0;
    float stretch = 40.0 + distance;
    float cycle = (time - startTime) * 5.0;

    float decay = exp(decayRate * distance);
    float wiggle = scale * (offset + sin(distance * stretch - cycle)); 
    float value = wiggle * decay;
    value /= float(wavesLength / 8);
    float saturation = .7;
    vec3 rgb = hsv2rgb(vec3(hue+time/20.0, saturation, value));
    return rgb;
}
vec3 decayingSquare(vec4 wave,vec2 pos) {
    vec2 fromCenter = abs(wave.xy - pos / resolution.yy);
    float distance = length(fromCenter);
    float hue = wave.w;
    float startTime = wave.z;

    float decayRate = -4.0;
    float scale = .5;
    float offset = 1.0;
    float stretch = 40.0 + distance;
    float cycle = (time - startTime) * 5.0;

    float decay = exp(decayRate * distance);
    float wiggle = scale * (offset + (floor(sin(distance * stretch - cycle)*0.5+1.0)-0.5)*2.0); 
    float value = wiggle * decay;
    value /= float(wavesLength / 8);
    float saturation = .7;
    vec3 rgb = hsv2rgb(vec3(hue+time/20.0, saturation, value));
    return rgb;
}
float peak(float x){
    return abs(2.0-mod(x/PI*2.0,4.0))-1.0;
}
vec3 decayingPeak(vec4 wave,vec2 pos) {
    vec2 fromCenter = abs(wave.xy - pos / resolution.yy);
    float distance = length(fromCenter);
    float hue = wave.w;
    float startTime = wave.z;

    float decayRate = -4.0;
    float scale = .5;
    float offset = 1.0;
    float stretch = 40.0 + distance;
    float cycle = (time - startTime) * 5.0;

    float decay = exp(decayRate * distance);
    float wiggle = scale * (offset + peak(distance * stretch - cycle)); 
    float value = wiggle * decay;
    value /= float(wavesLength / 8);
    float saturation = .7;
    vec3 rgb = hsv2rgb(vec3(hue+time/20.0, saturation, value));
    return rgb;
}
float receding(float startTime, float dist) {
    float cycle = timeCycle(startTime + time, 5.0);
    float scale = .5;
    float offset = 1.0;
    float value;

    float f = abs(dist - cycle);
    if (f < .05) {
        value = 1.0 - f*5.0;
    } else {
        value = 0.0;
    }

    return value;
}

vec3 squareWave(vec4 wave,vec2 pos) {
    float hue = wave.w;
    float startTime = wave.z;
    vec2 d = abs(wave.xy - pos / resolution.yy);    // vector to our pixel
    float distance = length(d);                                 // distance to our pixel

    float value = 0.0;

    float t = .5*(1.0+sin(time - startTime));  // sine oscillator zero to one and back in 
    float xDist = abs(d.x - t);
    float yDist = abs(d.y - t);
    if (xDist < .02 && abs(d.y) < t) {
        value = .7;
    } else if (yDist < .02 && abs(d.x) < t) {
        value = .7;
    }

    float saturation = .7;
    vec3 rgb = hsv2rgb(vec3(hue, saturation, value));
    return rgb;
}


/** color from one wave */
vec3 colorContrib(vec4 wave,vec2 pos) {
    if(waveType==2){
        return decayingSquare(wave,pos);
    }
    if(waveType==3){
        return decayingPeak(wave,pos);
    }
    return decayingSine(wave,pos);
}

/** accumulate a color from all the waves for this pixel. */
void main( void ) {
    vec3 color = vec3(0.0, 0.0, 0.0);
    if(mode==2){
                color=vec3(0.003);
            }
    for (int i =0; i < wavesLength; i++) {
        if (waves[i].z > 0.0) {
            
            if(mode==2){
                color += vec3(length(colorContrib(waves[i],gl_FragCoord.xy)));
                color -= vec3(length(colorContrib(waves[i],gl_FragCoord.xy+vec2(10.0)/resolution.xy)));
            }else{
                color += colorContrib(waves[i],gl_FragCoord.xy);
                
            }
        }
    }
if(mode==2){
                color=color*150.0;
            }
    gl_FragColor = vec4( color, 1.0 );
}

    </script>
</head>

<body onload="start();">
    <div class="stats" style="position:fixed; left:10; top: 10;">
        <table>
            <tr> <td> Frame rate:</td> 
                 <td> <span id="frameRate"> 0</span></td>
            </tr>
        </table>
    </div>
    <div id="shaderDiv">
        <canvas id="shader"></canvas>
    </div>
</body>

</html>
